//
// Created by remsc on 12/06/2025.
//

#include "Onyx.h"

#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>
#include <variant>

#include "CodeGenerator.h"
#include "Logger.h"
#include "Parser.h"
#include "SymbolTable.h"

// returns true if the given name is a valid module name (without .ox extension)
bool checkLib(const string& name) {
    for (const auto& entry : filesystem::recursive_directory_iterator("./")) {
        if (entry.is_regular_file() && entry.path().filename() == name + ".ox") {
            return true;
        }
    }
    return false;
}

optional<string> Onyx::Compile(const string &sourcefile) {
    auto map = BuildASTMap(sourcefile);
    // Prepass all the modules found
    SymbolTable table;
    for (auto &ast: map | views::values) {
        ast->prePass(table);
    }

    bool flag = false;
    // Analysis & code generation of used modules
    for (auto& [module, ast] : map) {
        ast->analyse(table);

        // Generate the #includes
        string imports;
        for (auto& imported : ast->statements) {
            if (auto importStmt = dynamic_cast<ExternStatementAST*>(imported.get())) {
                imports += "#include \"" + importStmt->libraryName + ".h\"\n";
            }
        }

        CodeGenerator generator(move(ast));

        // Generate code in './build/module.h'
        if (!filesystem::is_directory("build") || !filesystem::exists("build")) {
            filesystem::create_directory("build");
        }
        ofstream stream("build/" + module + ".h");
        if (stream.is_open()) {
            stream << "// Generated by Onyx compiler." << endl;
            stream << "#ifndef " << module << "_H" << endl << "#define " << module << "_H" << endl;

            // TODO : import builtins
            stream << "#include \"builtins.h\"" << endl << endl;

            stream << generator.generateHeader() << endl;

            stream << "#endif" << endl;
        }

        // Generate code in './build/module.c'
        stream = ofstream("build/" + module + ".c");
        if (stream.is_open()) {
            stream << "// Generated by Onyx compiler." << endl;
            stream << "#include \"" + module +".h\"" << endl;
            stream << imports;

            if (!flag) {
                flag = true;
                // Pool defined in the first module found, but initialised in the main function
                stream << "PtrIntList* global_pool;" << endl;
            }

            stream << generator.generate() << endl;
        }
        stream.close();
    }

    // Compilation
    string executable;
#ifdef OS_WINDOWS
    executable = "a.exe";
#else
    executable = "a.out";
#endif

    string buildFiles = "./build/memory.c";
    for (const auto &module: map | views::keys) {
        buildFiles += " ./build/" + module + ".c";
    }

    string buildFile = "./build/" + filesystem::path(sourcefile).stem().string() + ".c";
    string command = "clang " + buildFiles + " -o " + executable;
    std::cout << "Compiling program..." << endl;
    int result = system(command.c_str());
    if (result != 0) {
        std::cerr << "Error while compiling intermediate representation." << endl;
        return nullopt;
    }
    std::cout << "Intermediate representation compiled : " << executable << "." << endl;
    return "./" + executable;
}

// TODO : check if file found or not
unique_ptr<BlockAST> Onyx::BuildAST(const string& sourcefile) {
    std::ifstream file (sourcefile);
    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string content = buffer.str();

    Lexer lexer (content);
    Parser parser(lexer.tokenize());
    auto ast = parser.parse();
    return ast;
}

string moduleName(const string& path) {
    return filesystem::path(path).stem().string();
}
bool contains(const std::vector<string>& vec, const string& element) {
    for (const auto & i : vec) {
        if (i == element) {
            return true;
        }
    }
    return false;
}

map<string, unique_ptr<BlockAST>> Onyx::BuildASTMap(const string &sourcefile) {
    map<string, unique_ptr<BlockAST>> result;
    if (contains(visited, moduleName(sourcefile))) {
        return result;
    }
    auto main = BuildAST(sourcefile);
    vector<string> imports;
    // Look for all top-level extern statements
    for (auto& stmt : main->statements) {
        if (const auto ext = dynamic_cast<ExternStatementAST*>(stmt.get())) {
            if (checkLib(ext->libraryName)) {
                imports.emplace_back(ext->libraryName);
                continue;
            }
            Logger::Error("Module '" + ext->libraryName + "' not found.");
        }
    }
    for (const auto& mod : imports) {
        // Skip if the module has already been visited
        if (contains(visited, mod)) {
            continue;
        }
        // Build the module
        for (const auto& entry : filesystem::recursive_directory_iterator("./")) {
            if (entry.is_regular_file() && entry.path().filename() == mod + ".ox") {
                for (auto& [key, val] : BuildASTMap(entry.path().filename().string())) {
                    result.emplace(key, move(val));
                }
                visited.emplace_back(mod);
                break;
            }
        }
    }
    visited.emplace_back(moduleName(sourcefile));
    result.emplace(moduleName(sourcefile), move(main));
    return result;
}
